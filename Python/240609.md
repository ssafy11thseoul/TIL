# 파이썬
## ✅ Section 1: Python Basic

### 🧡 조건
```
a, b = 10, 5
# 1. a와 b가 같은 값을 갖는다
    a == b  # False

# 2. a가 b 이상
    a >== b # True    

# 3. a가 짝수
    a % 2 == 0, not a % 2 # (True, True)
    print(a % 2 == 0, not a % 2)
    # print를 함께 쓰면 True True 가 나옴

# 4. 여러 개의 객체를 콤마(,)를 사용해 나열하면 tuple이 된다. 
# 그래서 위에 나열한 값들도 (True, True) 이런식으로 결과가 나옴
    x = 1,2,3
    print(type(x), x)   
    # <class 'tuple'> (1, 2, 3)

# 5. a가 3의 배수이다
    a % 3 == 0, not a % 3  # (False, False)

# 6. a는 80보다 크고 90보다 작다
    a > 80 and a < 90, 80 < a < 90
    # (False, False)

# 7.  a는 100 보다 크거나 0보다 작다
    a >=100 or a <0 
    # False
```

### 🧡 input
```
# 1.   한 개 데이터를 입력 받아 그대로 출력해본다
#      123을 입력받고, type을 출력해 보면 어떤 결과인지 확인
    x = input('data: ')
    print(x, type(x))
    # 입출력 결과
    # data: 123
    # 123 <class 'str'>

# [2] 한 개 데이터를 입력 받아 int로 type을 변환하여 출력해 본다
    y = int(input('data: '))
    print(y, type(y))
    # 입출력 결과
    # data: 123
    # 123 <class 'int'>

# 다른 방법
    x = input('data: ')
    y = int(x)
    print(y, type(y))
    # 입출력 결과
    # data: 321
    # 321 <class 'int'>
```

### 🧡 형변환
```
# 1. 정수를 실수로 변환  (1 -> 1.0)
    r = float(1)
    print(r, type(r))
    # 1.0 <class 'float'>

# 2. 실수를 정수로 변환 (3.56 -> 3)
#    소수점 아래 잘림
    r = int(3.56)
    print(r, type(r))
    # 3 <class 'int'>

# 3. 문자열을 정수, 실수로 변환
# ("123" -> 123,  "3.14" -> 3.14)
    a = int("123")
    b = float("3.14")
    print(a, b, type(a), type(b)) 
    # 123 3.14 <class 'int'> <class 'float'>

# 4. bool을 정수로 변환 (False -> 0)
    r = int(False)
    print(r, type(r))
    # 0 <class 'int'>

# 5. 정수를 bool 타입으로 변환
# (1 -> True) (0 -> False)
    r = bool(-1)
    print(r, type(r))
    # True <class 'bool'>

# 6. 정수를 문자열로 변환(10 -> '10')
    r = str(10)
    print(r, type(r))
    # 10 <class 'str'>
```

### 🧡 함수(function)
- 함수 : 입력 데이터를 가지고 처리하여 결과를 반환하는 명령의 묶음
- 함수의 구성 : parameter, operation, return
- built-in 함수, 외부 함수 등 다양하게 준비된 함수가 있음
- 사용자가 만들어 사용할 수 있음
- 함수 vs 메서드(method)
    - 함수는 module(=파일)에서 가지고 있는 기능을 의미한다
    - 메서드는 class 내부에 작성된 함수이다
    - 함수와 메서드에 접근하기 위해서는 '.' 연산자를 사용하여 접근하도록 한다
```
def func(a, b):
    c = a + b
    d = a - b
    return c, d

r = func(10, 30)
print(r)
# (40, -20)
```
```
a = 1, 5, 3, 7, 2
# 1.  a의 합을 구한다
    r = sum(a)
    print(r)
    # 18
# 2.  a의 item 중에서 가장 큰 것을 구한다.
    r1 = max(a)
    r2 = max(1,5,3,7,2)
    print(r1,r2)   
    # 7 7 
# 3. a의 item 중에서 가장 작은 것을 구한다.
    r1 = min(a)
    r2 = min(1,5,3,7,2)
    print(r1, r2)
    # 1 1 
# 4. 객체의 메모리 사용량을 측정한다.
    import sys
    r = sys.getsizeof(a)
    print(r)
    # 80
# 5. index
    a = (1,2,3,4,7,5)    
    r = a.index(7)
    # 7의 인덱스가 r에 저장됨
    # 0번째 부터 시작 
    print(r)
    # 4 
# 6. 반올림을 한다
# round(x [,ndigits])
# ndigits는 음수, 0, 양수 일 수 있음
# x에 대해 ndigits에 따라 반올림
    num = 863.256
    print(round(num, 2))
    print(round(num, 1))
    print(round(num, 0))
    print(round(num, -1))
    print(round(num, -2))

    # 출력결과
    863.26
    863.3
    863.0
    860.0
    900.0
```

## ✅ Section 2: Containers
#### ✔️ Container : 여러 개의 객체(object)를 묶어서 사용하는 것
#### ✔️ Sequences : 순서가 있음. 순서번호(index)가 양수, 음수 2개 부여됨
  - tuple : item의 type에 제약이 없음. 수정(=갱신), 삭제, 추가가 불가능. 참조(Read only)
  - list : item의 type에 제약이 없음. 변경이 가능한 객체
  - str :  item으로 text만 가질 수 있음. 변경이 불가능한 객체
#### ✔️ Set types : {1, 2, 3} => Set의 item은 inmutable 한 성격을 갖는다 (tuple, str, int, float, bool)
#### ✔️ Mappings : { 'A': 10, 'B': 20} => Dict의 item은 key:value의 쌍으로 이루어짐, key는 immutable 한 성격을 가짐. value는 type에 제약 없음 
  - set, dict : 순서 없음(index가 없음) 추가, 삭제, 수정 등 가능

#### ➡️ item의 개수가 많아지면 사용되는 메모리가 증가 
```
range(start, stop, step)
➡️ 범위, 범위가 넓어져도 사용되는 메모리가 증가하지 않음. 정수 
# range(1.5, 2) 이런거 안됨 

# 기본값: 
start : 0
step : 1
stop: 반드시 정해 주어야 하는 값
예) 
```
```
1. 
range(5) # range(0,5,1) - 0 1 2 3 4 
list(range(5))
    # [0, 1, 2, 3, 4]

2. 
list(range(1,6)) # range(1,6,1) - 1 2 3 4 5
    # [1, 2, 3, 4, 5]

3. 
list(range(1,10,2)) # 1 3 5 7 9
    # [1, 3, 5, 7, 9]

4. 
list(range(5, 0, -1)) # 5 4 3 2 1
    # [5, 4, 3, 2, 1]
```

### 🧡 Sequence type : index 사용
- subscription : Sequence Container에서 특정 item을 가져오는 것 (=indexing)
- index 번호를 사용하여 특정 item을 선택한다
    - 인덱스는 순서를 나타내는 정수로 허용 범위가 아닌 경우 IndexError가 발생
    - 인덱스는 0번부터 시작하여 1씩 증가하며, 아이템 개수 -1 까지만 사용가능
    - 음수 인덱스의 경우 -1이 마지막 아이템의 위치
- slicing : slice(start:stop:step)을 사용하여 부분 container를 가져오는 것
    - 문자열 slicing -> 부분 문자열
    - 리스트 slicing -> 부분 리스트
- start, stop, step : 생략가능
    - start=0, stop=len(x), step=1 : default 값
    - 모두 생략시에는 ':' 은 포함해야 함
    - len(x) 는 x의 item 개수를 반환하는 함수
- list의 경우 Mutable이기 때문에 subscription, slicing을 사용한 갱신이 가능함
    - a가 list인 경우
    - a[n] = x # a의 n index의 값을 x로 변경
    - a[s:e] = [x, y, z] # a의 s부터 e-1의 값을 x, y, z으로 변경

```
1. str
    mystr = "801210-2123423"
    mystr[0], mystr[-1], mystr[7]
        # ('8', '3', '2')
    mystr[:], mystr[:6], mystr[7:]
        # ('801210-2123423', '801210', '2123423')

2. tuple
    mytuple = (1, 4, 6, 2, 3, 8)
    print(mytuple[1], mytuple[-2])
        # 4 3
    mytuple[::-1], mytuple[::2]
        # ((8, 3, 2, 6, 4, 1), (1, 6, 3))

3. list
    mylist = [7, 3, 8, 9, 1, 4]
    mylist[:-1]
        # [7, 3, 8, 9, 1]
    
    # [1] mylist 객체를 사용해 결과와 동일하도록 slice
    #  start에 음수 index를 사용할 것
    mylist[-2:] # [1, 4]

    # [2] mylist의 내용을 뒤집어 list를 생성해 보세요
    mylist[::-1]   # 뒤집기 [4, 1, 9, 8, 3, 7]

    # [3] mylist의 마지막에 한 개의 item을 제외하고 list를 생성해 보세요
    mylist[:5], mylist[:-1] # ([7, 3, 8, 9, 1], [7, 3, 8, 9, 1])

    # [4] mylist[2]의 값을 0으로 수정해 보세요.
    mylist[2] = 0
    mylist[:]   # [7, 3, 0, 9, 1, 4]

    # [5] mylist[2:3]의 값을 [10, 20, 30]으로 수정해 보세요.
    mylist[2:3] = [10,20,30]
    mylist  # [7, 3, 10, 20, 30, 9, 1, 4]

    # [6] mystr에서 year, month, day, gender 정보를 찾아 출력하라
    mystr = "801210-2123423"
    year, month, day = mystr[:2], mystr[2:4], mystr[4:6]
    gender = mystr[7]
    print(year, month, day, gender)     # 80 12 10 2

    # [7] slicing을 사용해 날짜와 날씨를 분리하여 저장하고, 출력해 보세요.
    day = '210901Windy'
    date, weather =day[:6], day[6:] # weather = [-5:]도 ㅇㅋ
    print(date, weather)    # 210901 Windy
```

### 🧡 Sequence type : 연산
- 덧셈 : 두 Container를 합친 Container 생성
- 곱셈 : Container를 n 번 복제한 Container 생성
```
# [1] 덧셈 사용 : a와 b 객체를 연결해서 하나의 객체를 생성합니다.
    a, b = [1, 2, 3], [4, 5]
    c = a + b
    print(c)
    # [1, 2, 3, 4, 5]

    # [2] 정수와의 곱셈 사용 : a 객체를 3번 복제해서 9개의 item을 갖는 객체를 생성합니다.
    a = [1, 2, 3]
    b = a * 3
    print(b)
    # [1, 2, 3, 1, 2, 3, 1, 2, 3]

    # [3] 서로 다른 container는 덧셈 연산할 수 없음 => type 변경을 한 뒤에 연산
    a, b = [1, 2, 3], (4, 5)
    # a + b  TypeError
    c = a + list(b)
    d = tuple(a) + b
    print(c, d)
    # [1, 2, 3, 4, 5] (1, 2, 3, 4, 5)
```

### 🧡 tuple 
- 다양한 생성방법이 있음, 한 개의 item일 경우 콤마(,)가 필요함
    - (1, )
    - (1, 2, 3)
    - 1,
    - 1, 2, 3
    - tuple(), tuple(iterable)
    - 주의 : (1) 은 tuple 아님
- 한 번 생성하면 변경할 수 없음 (Immutable)
- item의 type에 제한 없음
```
a = (1, 2, 3)
# exception 확인
# a[0] = 1 TypeError: 'tuple' object does not support item assignment

# [1] 1이라는 한 개의 item을 갖는 tuple을 생성합니다.
    a = 1,
    print(a, type(a))
    # (1,) <class 'tuple'>

# [2] 1, 3, 5, 7, 9를 item으로 하는 tuple을 생성합니다.
    # a = (1,3,5,7,9)
    a = tuple(range(1,10,2))
    print(a, type(a))
    # (1, 3, 5, 7, 9) <class 'tuple'>
```

### 🧡 list
- 다양한 생성방법이 있음
    - [1], [1, 2, 3]
    - list(), list(iterable)
- 생성 후 변경할 수 있음 (Mutable)
    - 연산 및 메서드를 사용한 삽입, 삭제, 갱신, 정렬 등의 작업이 가능함
- item의 type에 제한 없음
```
# [1] 0 ~ 9를 item으로 하는 list를 생성합니다
    a = list(range(10))
    print(a, type(a))
    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] <class 'list'>

# [2] mylist의 두 번째 item을 100으로 수정하여 출력합니다
    mylist = [10, 20, 30, 40]
    mylist[1] = 100
    print(mylist)
    # [10, 100, 30, 40]
```

### 🧡 list 메서드
1. 삽입/추가
```
# list.append(object) : list의 맨 뒤에 한 개 item을 추가
# [1] 300을 mylist의 맨 뒤에 추가
    mylist = [1,2,3,1,2,3,4]
    mylist.append(300)
    print(mylist)
    # [1, 2, 3, 1, 2, 3, 4, 300]

# list.extend(iterable) : list 맨 뒤에 여러 item을 추가
# [2] mylist 리스트의 뒤에 b를 넣어 확장
    b = (100, 200)
    mylist = [1,2,3,1,2,3,4]
    mylist.extend(b)
    print(mylist) 
    # [1, 2, 3, 1, 2, 3, 4, 100, 200]

# b가 튜플일 때 
    b = (100, 200)
    mylist = [1,2,3,1,2,3,4,]
    mylist += b # 왜 이건 되지?
    # mylist = mylist + b  이건 안됨 TypeError: can only concatenate list (not "tuple") to list

    mylist
    # [1, 2, 3, 1, 2, 3, 4, 100, 200] 

# b가 리스트일 때
    b = [100, 200]
    mylist = [1,2,3,1,2,3,4,]
    # mylist += b # 당연히 됨 
    mylist = mylist + b # 이것도 당연히 됨 

    mylist
    # [1, 2, 3, 1, 2, 3, 4, 100, 200]

# list.insert(index, object)
# list의 index 위치에 object를 삽입하고, 기존 item들은 뒤로 밀립니다.
# index 위치에 다른 object가 없었다면, 맨 뒤에 삽입됩니다.
# [3] 5번 index 위치에 100을 삽입합니다.
    mylist = list(range(10))
    mylist.insert(5,100)
    print(mylist)
    # [0, 1, 2, 3, 4, 100, 5, 6, 7, 8, 9]
```
2. 삭제 
```
# list.pop([index])
# 삭제할 데이터의 index 번호 지정, index 번호 지정하지 않으면 -1 위치
# 삭제 데이터를 반환도 합니다!
# [4] 4번 index의 item을 삭제하고 반환 받아 x라는 이름을 부여합니다.
    mylist = [10,20,30,10,20,40]
    x = mylist.pop(4)
    print(mylist,x)
    # [10, 20, 30, 10, 40] 20

# list.remove(value)
# 삭제할 데이터 지정, 앞에서부터 1개만 삭제됨
# [5] 20을 삭제합니다.
    mylist = [10,20,30,10,20,40]
    r = mylist.remove(20)
    print(mylist, r)
    # [10, 30, 10, 20, 40] None   

# list.clear()
    mylist = [10,20,30,10,20,40]
    mylist.clear()
    print(mylist)
    # []

# del 뒤의 item을 삭제함
# [6] del keyword 사용, mylist의 내용을 삭제하여 출력 결과가 [1, 3, 1, 2, 3, 4]가 되도록 합니다.
    mylist = [1,2,3,1,2,3,4]
    del mylist[1]
    print(mylist)
    # [1, 3, 1, 2, 3, 4]

# del 뒤의 slice를 삭제함
# [7] del keyword 사용, mylist의 내용을 삭제하여 출력 결과가 [1, 2, 3, 4]가 되도록 합니다.
    mylist = [1,2,3,1,2,3,4]
    del mylist[:3]
    print(mylist)
    # [1, 2, 3, 4]
```
3. 정렬
```
mylist = [1, 3, 2, 6, 5, 4]
mylist.sort()
print(mylist)
# [1, 2, 3, 4, 5, 6]

mylist = [1, 3, 2, 6, 5, 4]
mylist.sort(reverse=True)
print(mylist)
# [6, 5, 4, 3, 2, 1]
```

### 🧡 str 주요 메서드
1. 문자열 길이 
```
# len(x:container) : -> int
# [1] a의 길이 출력
    a = "Hello"
    b = len(a)
    print(b)
    # 5
    
    a = '가나다'
    b = len(a)
    print(b)
    # 3
```
2. 대문자, 소문자 변경
```
# [1] 대문자, 소문자 변경 => 문자열 반환
    a = 'Good Morning!'
    b,c = a.upper(), a.lower()
    print(b,c)
    # GOOD MORNING! good morning!

# [2] 대문자, 소문자 확인 => True/False 반환
    a = 'happy!!!'
    b,c = a.isupper(), a.islower()
    print(b,c)
    # False True
    # !는 알파벳 문자가 아니기 때문에 isupper()와 islower() 메서드에서 검사 대상에 포함X
    # 메서드의 반환 값은 문자열 내의 알파벳 문자들만 기준으로 결정됨
```
3. 문자열 분리 
```
# split
# 문자열의 split 함수를 사용하면 문자열의 list가 반환 됨
# str.split(sep:str) => 리스트 반환

# a를 ':'를  seperator로 하여 분리하기
    a = "A:B:C:D"
    b = a.split(':')
    print(b)
    # ['A', 'B', 'C', 'D']

# (참고) whitespace 문자
# https://docs.python.org/3/library/string.html
    import string
    string.whitespace
    # print(string.whitespace) 

# split의 구분자를 지정하지 않으면?
# 연속된 whitespace 문자를 1개의 구분자로 취급합니다.
# 구분자를 지정하지 않은 경우와 공백(' ')을 지정한 경우를 비교해 보세요.
    a = '    A   B  C   '                           #'\t\nA\nB     C   \n\r'
    b = a.split()     # 권장
    c = a.split(' ')  # 비권장
    d = ''.join(b)
    display(a, b, c)
    print(d)
    # '   A   B  C   '
    # ['A', 'B', 'C']
    # ['', '', '', '', 'A', '', '', 'B', '', 'C', '', '', '']
    # ABC

# 특정 횟수 만큼만 split 작업이 필요하다면 maxsplit 옵션
# 1번만 split 작업하기
    a = '2021-3-4'
    # b = a.split('-')
    b = a.split('-', maxsplit=1)
    print(b)
    # ['2021', '3-4']

# 오른쪽부터 왼쪽 방향으로 split 작업이 필요하다면 rsplit 메서드를 사용
    a = '2021-3-4'
    b = a.rsplit('-', maxsplit=1)
    print(b)
    # ['2021-3', '4']
```
4. join
```
# 구분자문자열.join(문자열을 item으로 하는 iterable)
# '-'를 구분자로 하여, a를 join 하도록 합니다.
    a = ['2020', '07', '13']
    b = '-'.join(a)
    print(b)
    # 2020-07-13

# ['A', 'B', 'C', 'D'] 를 'A:B:C:D'로 작성해 보세요
    a = ('A', 'B', 'C', 'D')
    b = ':'.join(a)
    print(b)
    # A:B:C:D
```
5. strip()
```
# str.strip() : 문자열 앞/뒤의 연속된 whitespace 문자를 제거
# a 문자열의 앞/뒤 연속된 whitespace 문자를 제거하여 b 라는 이름을 부여합니다.
    a = "    A   B   "
    b = a.strip()
    print(b)
    # A   B

# 예제
    e = 'www.jaen.com'
    f = e.strip('wocm')
    display(f)
    # '.jaen.'
    # strip('wocm')은 문자열의 양쪽 끝에서 w, o, c, m 문자를 제거. 이 문자들이 양쪽 끝에 있는 한 계속 제거.

🤷‍♀️ why?
# 시작 부분에서 'w' 제거: 'www.jaen.com'에서 'w' 제거 -> '.jaen.com'
# 끝 부분에서 'm' 제거: '.jaen.com'에서 'm' 제거 -> '.jaen.co'
# 끝 부분에서 'c' 제거: '.jaen.co'에서 'c' 제거 -> '.jaen.o'
# 끝 부분에서 'o' 제거: '.jaen.o'에서 'o' 제거 -> '.jaen.'
# 더 이상 양쪽 끝에 'w', 'o', 'c', 'm'이 없으므로 종료
# 따라서 최종적으로 '.jaen.'

# 즉, strip('wocm')은 지정된 문자 중 어떤 문자가 양 끝에 있든지 모두 제거하므로, 결과는 '.jaen.'
# Note: strip 메서드는 문자열의 중간에 있는 문자는 제거하지 않음. 양쪽 끝에 있는 지정된 문자만 제거
```

### 🧡 set의 특징
- 다양한 생성방법이 있음
    - {1}, {1, 2, 3}
    - set(), set(iterable)
- 생성 후 변경할 수 있음 (Mutable) : 연산 및 메서드를 사용한 삽입, 삭제, 갱신 등의 작업이 가능함
- item은 hashable 이어야 함 : hashable - int, float, bool, str, tuple 등
- 중복 item 제거 용도로 주로 사용됨
```
### 비교
a = ()
b = []
c = {}   # dict
d = set()
print(type(a), type(b), type(c), type(d))

# <class 'tuple'> <class 'list'> <class 'dict'> <class 'set'>
```
1. 집합 묶음 기호 
```
# 집합 묶음 기호를 사용한 생성
    a = {'a', 'b', 'c'}
    print(a)
    # 인덱스 번호 존재 x
    # {'c', 'b', 'a'}
```
2. 생성자 set() -> 중복 제거
```
# 생성자 set()를 사용한 중복 제거
    a = [1, 2, 3, 1, 2, 2, 3, 4]
    b = list(set(a))
    print(b)
    # [1, 2, 3, 4]

# (참고) hash 값이 같으면 같은 객체
    print(hash(1), hash(1.0), hash(True))   # 1 1 1
    1 == 1.0, 1.0 == True # (True, True)
    
    print(hash(0), hash(0.0), hash(False))  # 0 0 0 
    0 == 0.0, 0.0 == False  # (True, True)

    a = (1,2,3,5,6,7,8,3,0)
    b = (1,2,3,5,6,7,8,3,0)
    hash(a), hash(b)
    # (-7408958474292465415, -7408958474292465415)

# 다음의 결과는 무엇일까요?
    a = {1, 1.0, True}
    print(a)
    # {1}
```

### 🧡 dict의 특징
- 딕셔너리는 key와 value의 쌍 여러 개와 { }로 구성됨
    - dishes = {'eggs':2, 'sausage' :1, 'bacon':1, 'spam':500}
- key를 사용하여 value를 얻음
- item에 순서가 없음
- key는 고유 값을 설정해야하며 hashable이어야 함
    - hashable : immutable한 객체 (str, tuple, int, float, bool)
- 다양한 생성자 : 함수에 대한 parameter 학습 필요
    - dict()
    - dict(**kwargs)
    - dict(mapping, **kwargs)
    - dict(iterable, **kwargs)
```
# key는 hashable만 사용할 수 있으며
# hashable에는 int, float, bool, tuple, str 등이 있다.
# [1] 다양한 type의 key를 갖는 dict 객체를 생성해 보자!
    a = {1: 'one', 'two': 2, (1, 2) : 'tuple', 3.14 : 'pi'}
    print(a, type(a))
    # {1: 'one', 'two': 2, (1, 2): 'tuple', 3.14: 'pi'} <class 'dict'>
```
1. hash값이 같을 때 
```
# numeric의 True, 1, 1.0 은 같은 hash 값을 갖는다
# numeric의 False, 0, 0.0 은 같은 hash 값을 갖는다

# [2] 다음의 결과를 예측하세요! (^_^!!)
    x = {True : "one", 1 : "One", 1.0 : "ONE"}
    print(x)
    # {True: 'ONE'}
# Python 딕셔너리는 내부적으로 해시 테이블을 사용하여 키를 저장합니다. 
# 따라서 해시값이 같은 키들은 동일한 키로 간주됩니다. 
# True, 1, 1.0은 모두 같은 해시값을 가지며, 동일한 키로 취급되어 나중에 추가된 값이 앞의 값을 덮어씁니다.

# 이 코드에서 True, 1, 1.0 모두 같은 해시값을 가지므로:

# {True: "one"}: 초기 딕셔너리는 True 키와 "one" 값으로 구성됩니다.
# {True: "one", 1: "One"}: 1은 True와 동일한 키로 취급되므로 값이 "One"으로 대체됩니다.
# {True: "One", 1.0: "ONE"}: 1.0도 True와 동일한 키로 취급되므로 값이 "ONE"으로 대체됩니다.
# 결과적으로, 최종 딕셔너리는 {True: 'ONE'}가 됩니다.
```

### 🧡 dict 연산
- key를 사용하여 value 얻기 : r = d[key]
- 추가, 갱신 : d[key] = value
    - key가 존재하면 갱신, 존재하지 않으면 추가
- 삭제 : del d[key]
- 얻기, 삭제 동작시 존재하지 않는 key를 사용하면 KeyError 발생

```
# [1] dict 객체 생성
    mydict = {'Apple': '딸기', 'Watermelon': '수박'}
    print(mydict)
    # {'Apple': '딸기', 'Watermelon': '수박'}

# [2] 'Apple' 에 대한 값을 찾아 출력
    a = mydict['Apple']
    print(a)
    # 딸기

# [3] 'Apple'에 대한 값을 '사과'로 변경
    mydict['Apple'] = '사과'
    print(mydict)
    # {'Apple': '사과', 'Watermelon': '수박'}

# [4] 'Kiwi':'키위' item을 추가
    mydict['Kiwi'] = '키위'
    print(mydict)
    # {'Apple': '사과', 'Watermelon': '수박', 'Kiwi': '키위'}

# [5] del 키워드를 사용하여 'Apple'을 key로 하는 item 삭제
    del mydict['Apple']
    print(mydict)
    # {'Watermelon': '수박', 'Kiwi': '키위'}
```

### 🧡 dict 메서드
- dict.keys() : key 목록을 반환하는 메서드
- dict.values() : value 목록을 반환하는 메서드
- dict.items() : item 목록을 반환하는 메서드
```
# [1] dict 객체 생성
    mydict = {'name': 'Tom', 'age': 10}
    print(mydict)
    # {'name': 'Tom', 'age': 10}

# [2] mydict 의 key 목록을 출력한다
    mydict.keys() # dict_keys(['name', 'age'])
    list(mydict.keys()) # ['name', 'age']
    # ['name', 'age']

# [3] mydict 의 value 목록을 출력한다
    list(mydict.values())
    # ['Tom', 10]

# [3] mydict 의 item 목록을 출력한다
    list(mydict.items())
    # 키와 밸류가 튜플로 반환됨 [('name', 'Tom'), ('age', 10)]

# [4] mydict 에서 'height'의 value를 반환 받아 출력한다
    # mydict['height'] # KeyError
# dict.get(key, default=None) : key에 해당하는 item의 value를 반환한다 (삭제는 하지 않음)
# key에 해당하는 item이 없으면 default를 반환한다. default 지정하지 않으면 None 반환
    x = mydict.get('height',-1)

    if x == -1:
    print('there is no "height" in keys')
    # there is no "height" in keys

# [5] 문자열에 ''나 ""를 함께 출력하고 싶을 때
    print('abc', "abc", "a'bc", 'a"bc')
    # abc abc a'bc a"bc
```

### 🧡 Container 형 변환
```
# [1] 문자열을 list로 변환
    a = 'Python'
    b = list(a)
    print(b)
    # ['P', 'y', 't', 'h', 'o', 'n']

# [2] list를 tuple로 변환
    a = [1,2,3,4,5]
    b = tuple(a)
    print(b)
    # (1, 2, 3, 4, 5)

# [3] list를 중복제거하여 다시 list로 변환
    a = [1,2,3,2,3,5,2,3,7,2,3]
    list(set(a))
    # [1, 2, 3, 5, 7]
```

### 🧡 Comprehension
- list, set,dict를 만드는 기법
- [object for x in iterable if 조건]
    - iterable : 여러 개의 item을 갖는 Container 및 반복자
    - for x in iterable : item을 만들기 위한 재료
    - if 조건: 재료의 유효성 검사(사용할지 말지)
    - object: item으로 사용될 객체(연산식, 함수호출식 사용 가능)
1. 기본 형태
```
[ x for x in [1,2,3]]
    # [1, 2, 3]
[x for x in range(1,5)]
    # [1, 2, 3, 4]
```
2. 조건 달기
```
[ x for x in range(1,5) if not x%2]
    # [2, 4]

[ x*2 for x in range(1, 5) if not x%2]
    # [4, 8]

[str(x) for x in range(1,5) if not x%2]
    # ['2', '4']

a = input().split()
print(a)
    # 1 2 3 4 5 입력
    # ['1', '2', '3', '4', '5']

a = [int(x) for x in input().split()]
print(a)
    # 1 2 3 4 5 입력
    # [1, 2, 3, 4, 5]
```
3. 응용
```
# [1] '0', '1', '2', '3', ... '9'를 item으로 갖는 list를 작성해 보자
    a = [str(x) for x in range(10)]
    print(a)
    # ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

# [2] 2**0, 2**1, 2**2, 2**3, ...2**9 을 item으로 갖는 list를 작성해 보자
    a = [ 2**x for x in range(10)]
    print(a)
    # [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]

# [3] 1**2, 2**2, 3**2, 4**2, ... 9**2 을 item으로 갖는 set을 작성해 보자
    a = {x**2 for x in range(1,10)}
    print(a)
    # {64, 1, 4, 36, 9, 16, 49, 81, 25}

# [4] key:value의 item을  value가 key로 사용되고, key가 value로 사용되도록 변경하여보자
    a = {'A': 1, 'B': 2, 'C': 3}
    b = [x for x in a.items()]
    print(b) # [('A', 1), ('B', 2), ('C', 3)] 튜플로 나옴
    c = {v:k for k,v in a.items()}
    print(c)
    # [('A', 1), ('B', 2), ('C', 3)]
    # {1: 'A', 2: 'B', 3: 'C'}

# [5] 튜플을 리스트로 변경
    a = [ [x, y] for x, y in [(1, 2), (2, 3), (4, 5)] ]
    print(a)
    # [[1, 2], [2, 3], [4, 5]]
```